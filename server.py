from flask import Flask, request, send_from_directoryfrom flask_socketio import SocketIO, emitfrom flask_cors import CORSimport requestsimport firebase_adminfrom firebase_admin import credentials, dbimport osimport threadingapp = Flask(__name__)CORS(app)socketio = SocketIO(app, cors_allowed_origins="*")cred = credentials.Certificate("service_account.json")firebase_admin.initialize_app(cred, {"databaseURL": "https://chat-app-d2935-default-rtdb.firebaseio.com/"})FIREBASE_URL = "https://chat-app-d2935-default-rtdb.firebaseio.com/chat.json"UPLOAD_FOLDER = "uploads"if not os.path.exists(UPLOAD_FOLDER):    os.makedirs(UPLOAD_FOLDER)def post(data):    requests.post(FIREBASE_URL, json=data)def edit(data):    message_id = data["message_id"]    new_message = data["new_message"]    if message_id and new_message:        # Locate the message in Firebase using message_id        messages_ref = db.reference("chat")  # Adjust this if your messages are stored differently        messages = messages_ref.get()        if messages:            for key, msg in messages.items():                if msg.get("message_id") == message_id:                    # Update the message content in Firebase                    messages_ref.child(key).update({"message": new_message})                    break  # Exit loop after finding the messagedef delete(data):    message_id = data["message_id"]    if message_id:        messages_ref = db.reference("chat")  # Adjust if needed        messages = messages_ref.get()        if messages:            for key, msg in messages.items():                if msg.get("message_id") == message_id:                    messages_ref.child(key).delete()  # Remove from Firebase                    break  # Exit after deleting@app.route('/uploads/<filename>')def download_file(filename):    return send_from_directory(UPLOAD_FOLDER, filename)@socketio.on("message")def handle_message(data):    print(f"Message: {data}")    message = data["message"]    emit("message", data, broadcast=True)    sender = data["sender"]    message_id = data["message_id"]    time = data ["time"]    threading.Thread(target=post, args=(data,)).start()    #requests.post(FIREBASE_URL, json={"message": message,"sender":sender,"message_id":message_id,"time":time})    file_parts = {}@socketio.on("edit_message")def edit_message(data):    """Edit a particular message in Firebase and notify all clients."""    message_id = data["message_id"]    new_message = data["new_message"]    user = data["user"]    emit("edit_message", {"message_id": message_id, "new_message": new_message,"user": user}, broadcast=True)    threading.Thread(target=edit, args=(data,)).start()    if message_id and new_message:        # Locate the message in Firebase using message_id        messages_ref = db.reference("chat")  # Adjust this if your messages are stored differently        messages = messages_ref.get()        if messages:            for key, msg in messages.items():                if msg.get("message_id") == message_id:                    # Update the message content in Firebase                    messages_ref.child(key).update({"message": new_message})                    break  # Exit loop after finding the message        # Notify all clients about the edit@socketio.on("delete_message")def delete_message(data):    """Broadcast a message deletion event."""    message_id = data["message_id"]    emit("delete_message", {"message_id": message_id}, broadcast=True)    threading.Thread(target=delete, args=(data,)).start()    @socketio.on("file_chunk")def handle_file_chunk(data):    filename = data["filename"]    filedata = data["chunk"]    total_chunks = data["total_chunks"]    chunk_index = data["chunk_index"]    if filename not in file_parts:        file_parts[filename] = b""    file_parts[filename] += filedata    progress = (chunk_index + 1) / total_chunks * 100    emit("upload_progress", {"filename": filename, "progress": progress}, broadcast=True)    if chunk_index + 1 == total_chunks:  # Final chunk received        filepath = os.path.join(UPLOAD_FOLDER, filename)        with open(filepath, "wb") as f:            f.write(file_parts.pop(filename))  # Save file        file_url = f"http://127.0.0.1:5000/uploads/{filename}"        emit("file_received", {"filename": filename, "url": file_url}, broadcast=True)@socketio.on("typing")def user_typing(data):    socketio.emit("typing", data)@socketio.on("stopped_typing")def user_stopped_typing(data):    socketio.emit("stopped_typing", data)@socketio.on("play_music")def play_music(data):    """ Broadcast music URL to all users """    print(f"ðŸ”Š Broadcasting song: {data}")  # Debugging    socketio.emit("play_music", data)if __name__ == "__main__":    socketio.run(app, host="0.0.0.0", port=5000, debug=True)